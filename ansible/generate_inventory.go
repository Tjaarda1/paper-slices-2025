package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

type tfState struct {
	Outputs struct {
		ClusterIPs struct {
			Value map[string]struct {
				Cluster string `json:"cluster"`
				IP      string `json:"ip"`
				Role    string `json:"role"`
			} `json:"value"`
		} `json:"cluster_ips"`
		PrometheusIP struct {
			Value string `json:"value"`
		} `json:"prometheus_ip"`
	} `json:"outputs"`
}


type hostVars struct{ IP string }

type clusterAgg struct {
	Control string
	Workers []string
	Hosts   map[string]hostVars
}

func main() {
	in := flag.String("input", "", "Terraform JSON file (reads stdin if blank)")
	outDir := flag.String("outdir", "local/config", "Directory for generated inventories")
	controlSchedulable := flag.Bool("control-schedulable", true, "Put control node in [kube_node]")
	flag.Parse()

	raw, err := os.ReadFile(orDefault(*in, "/dev/stdin"))
	if err != nil {
		log.Fatalf("read input: %v", err)
	}

	var st tfState
	if err := json.Unmarshal(raw, &st); err != nil {
		log.Fatalf("parse json: %v", err)
	}

	if len(st.Outputs.ClusterIPs.Value) == 0 {
		log.Fatal("outputs.cluster_ips.value is empty")
	}

	// Aggregate per-cluster data.
	cl := map[string]*clusterAgg{}
	for name, v := range st.Outputs.ClusterIPs.Value {
		c := v.Cluster
		if cl[c] == nil {
			cl[c] = &clusterAgg{Hosts: map[string]hostVars{}}
		}
		cl[c].Hosts[name] = hostVars{IP: v.IP}
		if v.Role == "control-node" {
			cl[c].Control = name
		} else {
			cl[c].Workers = append(cl[c].Workers, name)
		}
	}

	// Add synthetic "monitoring" cluster for Prometheus
	if st.Outputs.PrometheusIP.Value != "" {
		const promCluster = "monitoring"
		const promHost = "prometheus"

		cl[promCluster] = &clusterAgg{
			Control: promHost,
			Hosts: map[string]hostVars{
				promHost: {IP: st.Outputs.PrometheusIP.Value},
			},
		}
	}


	// Stable ordering.
	var clusters []string
	for k := range cl {
		clusters = append(clusters, k)
	}
	sort.Strings(clusters)

	if err := os.MkdirAll(*outDir, 0o755); err != nil {
		log.Fatalf("mkdir %s: %v", *outDir, err)
	}

	// Generate inventories.
	for _, cname := range clusters {
		agg := cl[cname]
		sort.Strings(agg.Workers)

		if agg.Control == "" {
			log.Fatalf("cluster %s has no control node", cname)
		}

		file := filepath.Join(*outDir, fmt.Sprintf("inventory-%s.ini", cname))
		if err := os.WriteFile(file, []byte(renderINI(agg, *controlSchedulable)), 0o644); err != nil {
			log.Fatalf("write %s: %v", file, err)
		}
		log.Printf("wrote %s for cluster %q (control=%s, workers=%d)", file, cname, agg.Control, len(agg.Workers))
	}
}

func renderINI(agg *clusterAgg, controlSchedulable bool) string {
	allHosts := make([]string, 0, 1+len(agg.Workers))
	allHosts = append(allHosts, agg.Control)
	allHosts = append(allHosts, agg.Workers...)
	sort.Strings(allHosts)

	sb := &strings.Builder{}
	sb.WriteString("# Generated by gen-kubespray-inventories\n\n")

	// [all] with per-host variables
	sb.WriteString("[all]\n")
	for _, h := range allHosts {
		ip := agg.Hosts[h].IP
		fmt.Fprintf(sb, "%s ansible_host=%s ip=%s access_ip=%s ansible_user=ubuntu ansible_become=true\n", h, ip, ip, ip)
	}
	sb.WriteString("\n")

	// kube_control_plane
	sb.WriteString("[kube_control_plane]\n")
	fmt.Fprintln(sb, agg.Control, "\n")

	// etcd
	sb.WriteString("[etcd]\n")
	fmt.Fprintln(sb, agg.Control, "\n")

	// kube_node
	sb.WriteString("[kube_node]\n")
	if controlSchedulable {
		fmt.Fprintln(sb, agg.Control)
	}
	for _, w := range agg.Workers {
		fmt.Fprintln(sb, w)
	}
	sb.WriteString("\n")

	// empty groups
	sb.WriteString("[calico_rr]\n\n[bastion]\n\n")

	// k8s_cluster children union
	// sb.WriteString("[k8s_cluster:children]\n")
	// sb.WriteString("kube_control_plane\nkube_node\ncalico_rr\n")

	return sb.String()
}

func orDefault(v, def string) string {
	if v != "" {
		return v
	}
	return def
} 